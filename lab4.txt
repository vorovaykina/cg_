import javax.swing.*;
import java.awt.*;
import java.io.*;
import java.util.*;
import java.util.List;

// Основной класс приложения
public class Main extends JFrame {
    private ClippingPanel panel;

    public Main() {
        setTitle("Алгоритмы отсечения отрезков и многоугольников");
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setSize(1000, 800);

        panel = new ClippingPanel();
        add(panel, BorderLayout.CENTER);

        JPanel controlPanel = new JPanel();
        JButton loadButton = new JButton("Загрузить файл");
        JButton manualInputButton = new JButton("Ввести данные вручную");
        JButton clipLinesButton = new JButton("Отсечь отрезки (Средняя точка)");
        JButton clipPolygonButton = new JButton("Отсечь многоугольник");
        JButton clearButton = new JButton("Очистить");

        loadButton.addActionListener(e -> loadFromFile());
        manualInputButton.addActionListener(e -> panel.loadFromTextDialog());
        clipLinesButton.addActionListener(e -> panel.clipLines());
        clipPolygonButton.addActionListener(e -> panel.clipPolygon());
        clearButton.addActionListener(e -> panel.clear());

        controlPanel.add(loadButton);
        controlPanel.add(manualInputButton);
        controlPanel.add(clipLinesButton);
        controlPanel.add(clipPolygonButton);
        controlPanel.add(clearButton);

        add(controlPanel, BorderLayout.SOUTH);
        setLocationRelativeTo(null);
    }

    private void loadFromFile() {
        JFileChooser fileChooser = new JFileChooser();
        if (fileChooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) {
            try {
                panel.loadData(fileChooser.getSelectedFile());
            } catch (IOException ex) {
                JOptionPane.showMessageDialog(this, "Ошибка загрузки файла: " + ex.getMessage());
            }
        }
    }

    public static void main(String[] args) {
        SwingUtilities.invokeLater(() -> {
            Main app = new Main();
            app.setVisible(true);
        });
    }
}


// Панель для отрисовки
class ClippingPanel extends JPanel {
    private List<Line> lines = new ArrayList<>();
    private List<Line> clippedLines = new ArrayList<>();
    private List<Point2D> polygon = new ArrayList<>();
    private List<Point2D> clippedPolygon = new ArrayList<>();
    private Rectangle2D clipWindow;
    private boolean showClipped = false;
    private boolean showClippedPolygon = false;

    private double minX, maxX, minY, maxY;
    private int padding = 50;

    public ClippingPanel() {
        setBackground(Color.WHITE);
    }

    // -------------------------
    // Загрузка из файла
    // -------------------------
    public void loadData(File file) throws IOException {
        BufferedReader reader = new BufferedReader(new FileReader(file));

        String text = reader.lines().reduce("", (a, b) -> a + "\n" + b);
        reader.close();

        loadDataFromText(text);
    }

    // -------------------------
    // Диалог ручного ввода текста
    // -------------------------
    public void loadFromTextDialog() {
        JTextArea textArea = new JTextArea(20, 40);
        JScrollPane scrollPane = new JScrollPane(textArea);

        int result = JOptionPane.showConfirmDialog(
                this,
                scrollPane,
                "Введите данные",
                JOptionPane.OK_CANCEL_OPTION
        );

        if (result == JOptionPane.OK_OPTION) {
            try {
                loadDataFromText(textArea.getText());
            } catch (Exception ex) {
                JOptionPane.showMessageDialog(this,
                        "Ошибка чтения данных: " + ex.getMessage());
            }
        }
    }

    // -------------------------
    // Парсер текста (общий)
    // -------------------------
    public void loadDataFromText(String text) throws IOException {
        lines.clear();
        polygon.clear();
        clippedLines.clear();
        clippedPolygon.clear();
        showClipped = false;
        showClippedPolygon = false;

        BufferedReader reader = new BufferedReader(new StringReader(text));

        String line = reader.readLine();
        if (line == null) throw new IOException("Нет данных.");
        int n = Integer.parseInt(line.trim());

        for (int i = 0; i < n; i++) {
            line = reader.readLine();
            if (line == null) throw new IOException("Недостаточно строк для отрезков.");
            String[] parts = line.trim().split("\\s+");
            double x1 = Double.parseDouble(parts[0]);
            double y1 = Double.parseDouble(parts[1]);
            double x2 = Double.parseDouble(parts[2]);
            double y2 = Double.parseDouble(parts[3]);
            lines.add(new Line(x1, y1, x2, y2));
        }

        line = reader.readLine();
        if (line == null) throw new IOException("Нет строки окна отсечения.");
        String[] parts = line.trim().split("\\s+");
        double xmin = Double.parseDouble(parts[0]);
        double ymin = Double.parseDouble(parts[1]);
        double xmax = Double.parseDouble(parts[2]);
        double ymax = Double.parseDouble(parts[3]);

        clipWindow = new Rectangle2D(xmin, ymin, xmax, ymax);

        calculateBounds();
        repaint();
    }

    // -------------------------
    private void calculateBounds() {
        minX = clipWindow.xmin;
        maxX = clipWindow.xmax;
        minY = clipWindow.ymin;
        maxY = clipWindow.ymax;

        for (Line l : lines) {
            minX = Math.min(minX, Math.min(l.x1, l.x2));
            maxX = Math.max(maxX, Math.max(l.x1, l.x2));
            minY = Math.min(minY, Math.min(l.y1, l.y2));
            maxY = Math.max(maxY, Math.max(l.y1, l.y2));
        }

        double rangeX = maxX - minX;
        double rangeY = maxY - minY;
        minX -= rangeX * 0.1;
        maxX += rangeX * 0.1;
        minY -= rangeY * 0.1;
        maxY += rangeY * 0.1;
    }

    // -------------------------
    public void clipLines() {
        if (clipWindow == null) return;

        clippedLines.clear();
        MidpointClipping clipper = new MidpointClipping(clipWindow);

        for (Line l : lines) {
            Line clipped = clipper.clip(l);
            if (clipped != null) clippedLines.add(clipped);
        }

        showClipped = true;
        repaint();
    }

    public void clipPolygon() {
        if (lines.isEmpty() || clipWindow == null) return;

        polygon.clear();
        for (Line l : lines) {
            polygon.add(new Point2D(l.x1, l.y1));
        }

        SutherlandHodgmanClipping clipper = new SutherlandHodgmanClipping(clipWindow);
        clippedPolygon = clipper.clip(polygon);
        showClippedPolygon = true;
        repaint();
    }

    public void clear() {
        lines.clear();
        clippedLines.clear();
        polygon.clear();
        clippedPolygon.clear();
        clipWindow = null;
        showClipped = false;
        showClippedPolygon = false;
        repaint();
    }

    // -------------------------
    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        Graphics2D g2d = (Graphics2D) g;
        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

        if (clipWindow == null) return;

        drawAxes(g2d);
        drawClipWindow(g2d);

        if (!showClippedPolygon) {
            drawLines(g2d);
            if (showClipped) drawClippedLines(g2d);
        } else {
            drawPolygon(g2d, polygon, new Color(100, 100, 255), false);
            drawPolygon(g2d, clippedPolygon, new Color(0, 200, 0), true);
        }
    }

    private void drawAxes(Graphics2D g2d) {
        g2d.setColor(Color.LIGHT_GRAY);
        g2d.setStroke(new BasicStroke(1));

        int w = getWidth() - 2 * padding;
        int h = getHeight() - 2 * padding;

        g2d.drawLine(padding, padding, padding, padding + h);
        g2d.drawLine(padding, padding + h, padding + w, padding + h);

        g2d.setColor(Color.BLACK);
        g2d.setFont(new Font("Arial", Font.PLAIN, 10));

        for (int i = 0; i <= 10; i++) {
            double x = minX + (maxX - minX) * i / 10.0;
            int px = padding + (int)(w * i / 10.0);
            g2d.drawString(String.format("%.1f", x), px - 15, padding + h + 15);

            double y = minY + (maxY - minY) * i / 10.0;
            int py = padding + h - (int)(h * i / 10.0);
            g2d.drawString(String.format("%.1f", y), padding - 35, py + 5);
        }
    }

    private void drawClipWindow(Graphics2D g2d) {
        g2d.setColor(new Color(255, 200, 200));
        g2d.setStroke(new BasicStroke(2));

        int x1 = toScreenX(clipWindow.xmin);
        int y1 = toScreenY(clipWindow.ymax);
        int x2 = toScreenX(clipWindow.xmax);
        int y2 = toScreenY(clipWindow.ymin);

        g2d.drawRect(x1, y1, x2 - x1, y2 - y1);
    }

    private void drawLines(Graphics2D g2d) {
        g2d.setColor(Color.BLUE);
        g2d.setStroke(new BasicStroke(1));

        for (Line l : lines) {
            int x1 = toScreenX(l.x1);
            int y1 = toScreenY(l.y1);
            int x2 = toScreenX(l.x2);
            int y2 = toScreenY(l.y2);
            g2d.drawLine(x1, y1, x2, y2);
        }
    }

    private void drawClippedLines(Graphics2D g2d) {
        g2d.setColor(new Color(0, 200, 0));
        g2d.setStroke(new BasicStroke(3));

        for (Line l : clippedLines) {
            int x1 = toScreenX(l.x1);
            int y1 = toScreenY(l.y1);
            int x2 = toScreenX(l.x2);
            int y2 = toScreenY(l.y2);
            g2d.drawLine(x1, y1, x2, y2);
        }
    }

    private void drawPolygon(Graphics2D g2d, List<Point2D> points, Color color, boolean fill) {
        if (points.isEmpty()) return;

        int[] xPoints = new int[points.size()];
        int[] yPoints = new int[points.size()];

        for (int i = 0; i < points.size(); i++) {
            xPoints[i] = toScreenX(points.get(i).x);
            yPoints[i] = toScreenY(points.get(i).y);
        }

        g2d.setColor(color);
        if (fill) g2d.fillPolygon(xPoints, yPoints, points.size());
        else {
            g2d.setStroke(new BasicStroke(1));
            g2d.drawPolygon(xPoints, yPoints, points.size());
        }
    }

    private int toScreenX(double x) {
        int w = getWidth() - 2 * padding;
        return padding + (int)((x - minX) / (maxX - minX) * w);
    }

    private int toScreenY(double y) {
        int h = getHeight() - 2 * padding;
        return padding + h - (int)((y - minY) / (maxY - minY) * h);
    }
}


// =================================================================
// Вспомогательные классы
// =================================================================

class Line {
    double x1, y1, x2, y2;
    public Line(double x1, double y1, double x2, double y2) {
        this.x1 = x1; this.y1 = y1; this.x2 = x2; this.y2 = y2;
    }
}

class Point2D {
    double x, y;
    public Point2D(double x, double y) {
        this.x = x; this.y = y;
    }
}

class Rectangle2D {
    double xmin, ymin, xmax, ymax;
    public Rectangle2D(double xmin, double ymin, double xmax, double ymax) {
        this.xmin = xmin; this.ymin = ymin; this.xmax = xmax; this.ymax = ymax;
    }
}

// =================================================================
// Алгоритм средней точки
// =================================================================
class MidpointClipping {
    private Rectangle2D w;

    public MidpointClipping(Rectangle2D window) {
        this.w = window;
    }

    public Line clip(Line L) {
        return clipRec(L.x1, L.y1, L.x2, L.y2);
    }

    private Line clipRec(double x1, double y1, double x2, double y2) {

        int c1 = code(x1, y1);
        int c2 = code(x2, y2);

        if ((c1 | c2) == 0)
            return new Line(x1, y1, x2, y2);
        if ((c1 & c2) != 0)
            return null;

        if (dist(x1, y1, x2, y2) < 0.5) {
            if (isInside(x1, y1)) return new Line(x1, y1, x1, y1);
            if (isInside(x2, y2)) return new Line(x2, y2, x2, y2);
            return null;
        }

        double xm = (x1 + x2) / 2;
        double ym = (y1 + y2) / 2;

        Line left = clipRec(x1, y1, xm, ym);
        Line right = clipRec(xm, ym, x2, y2);

        if (left == null) return right;
        if (right == null) return left;

        return new Line(left.x1, left.y1, right.x2, right.y2);
    }

    private boolean isInside(double x, double y) {
        return x >= w.xmin && x <= w.xmax &&
                y >= w.ymin && y <= w.ymax;
    }

    private double dist(double x1, double y1, double x2, double y2) {
        return Math.hypot(x2 - x1, y2 - y1);
    }

    private int code(double x, double y) { int code = 0;
        if (x < w.xmin) code |= 1;
        if (x > w.xmax) code |= 2;
        if (y < w.ymin) code |= 4;
        if (y > w.ymax) code |= 8;
        return code; }
}

    private int computeCode(double x, double y) {
        int code = 0;
        if (x < window.xmin) code |= 1;
        if (x > window.xmax) code |= 2;
        if (y < window.ymin) code |= 4;
        if (y > window.ymax) code |= 8;
        return code;
    }
}

// =================================================================
// Алгоритм Сазерленда–Ходжмана
// =================================================================
class SutherlandHodgmanClipping {
    private Rectangle2D window;

    public SutherlandHodgmanClipping(Rectangle2D window) {
        this.window = window;
    }

    public List<Point2D> clip(List<Point2D> polygon) {
        List<Point2D> result = new ArrayList<>(polygon);

        result = clipAgainstEdge(result, window.xmin, 0);
        result = clipAgainstEdge(result, window.xmax, 1);
        result = clipAgainstEdge(result, window.ymin, 2);
        result = clipAgainstEdge(result, window.ymax, 3);

        return result;
    }

    private List<Point2D> clipAgainstEdge(List<Point2D> poly, double edge, int type) {
        List<Point2D> result = new ArrayList<>();
        if (poly.isEmpty()) return result;

        for (int i = 0; i < poly.size(); i++) {
            Point2D cur = poly.get(i);
            Point2D next = poly.get((i + 1) % poly.size());

            boolean curIn = isInside(cur, edge, type);
            boolean nextIn = isInside(next, edge, type);

            if (curIn && nextIn) {
                result.add(next);
            } else if (curIn && !nextIn) {
                Point2D I = getIntersection(cur, next, edge, type);
                if (I != null) result.add(I);
            } else if (!curIn && nextIn) {
                Point2D I = getIntersection(cur, next, edge, type);
                if (I != null) result.add(I);
                result.add(next);
            }
        }

        return result;
    }

    private boolean isInside(Point2D p, double edge, int type) {
        switch (type) {
            case 0: return p.x >= edge;
            case 1: return p.x <= edge;
            case 2: return p.y >= edge;
            case 3: return p.y <= edge;
        }
        return false;
    }

    private Point2D getIntersection(Point2D p1, Point2D p2, double edge, int type) {
        double x, y, t;

        switch (type) {
            case 0: case 1:
                if (Math.abs(p2.x - p1.x) < 1e-10) return null;
                t = (edge - p1.x) / (p2.x - p1.x);
                y = p1.y + t * (p2.y - p1.y);
                return new Point2D(edge, y);

            case 2: case 3:
                if (Math.abs(p2.y - p1.y) < 1e-10) return null;
                t = (edge - p1.y) / (p2.y - p1.y);
                x = p1.x + t * (p2.x - p1.x);
                return new Point2D(x, edge);
        }

        return null;
    }
}
